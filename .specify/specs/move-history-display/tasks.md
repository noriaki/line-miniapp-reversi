# Implementation Plan

## Task Format Template

以下の実装タスクは、着手履歴(棋譜)表示機能を段階的に実装するための詳細な計画です。各タスクは1-3時間で完了可能なサイズに設計されており、全ての要件を網羅しています。

---

- [x] 1. 棋譜変換ロジックの実装
  - 盤面座標を棋譜記法に変換する機能を実装する
  - 列インデックス(0-7)を文字(a-h)に変換する機能を作成する
  - 行インデックス(0-7)を数字(1-8)に変換する機能を作成する
  - Position型を受け取り2文字の棋譜記法文字列を返すPure Functionとして実装する
  - 座標範囲外の場合は開発環境でconsole.warnを出力しフォールバック値"??"を返す
  - TypeScript strict mode準拠、Immutableパターンで実装する
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 6.1, 6.2, 6.4_

- [x] 1.1 positionToNotation関数の単体テスト作成
  - 境界値テスト: (0,0)→"a1", (7,7)→"h8", (2,6)→"c7", (3,4)→"d5"を検証する
  - 全座標変換テスト: 8x8=64通りの全座標が正しく変換されることを検証する
  - 列a-h、行1-8の範囲が完全に網羅されていることを確認する
  - Pure Functionとして同じ入力に常に同じ出力を返すことを検証する
  - 型安全性テスト: TypeScript strict modeでコンパイルエラーがないことを確認する
  - エラーケーステスト: 範囲外座標で"??"が返ることを確認する
  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 6.5, 6.6_

- [x] 2. 棋譜文字列生成ロジックの実装
  - 棋譜履歴配列を受け取り連結文字列を生成する機能を実装する
  - 空配列の場合は空文字列を返す機能を作成する
  - 区切り文字やスペースを含めずに単純連結する機能を実装する
  - readonly配列を受け取るImmutableなPure Functionとして実装する
  - 既存の棋譜履歴を変更せず新しい文字列を生成する
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 6.3, 6.4_

- [x] 2.1 generateNotationString関数の単体テスト作成
  - 基本ケーステスト: 空配列→"", ["e6"]→"e6", ["e6","f6","f5"]→"e6f6f5"を検証する
  - エッジケーステスト: 長い履歴(60手以上)でも正常に連結されることを確認する
  - ReadonlyArrayの不変性検証: 入力配列が変更されないことを確認する
  - Pure Functionとして副作用がないことを検証する
  - 型安全性テスト: readonly modifiersが正しく機能することを確認する
  - _Requirements: 3.1, 3.2, 3.3, 3.4, 3.5, 6.3, 6.4, 6.5, 6.6_

- [x] 3. useGameStateへの棋譜管理機能追加
  - moveHistory状態(string配列)をuseGameState内に追加する
  - notationString導出値を実装する(generateNotationStringで毎回計算、useMemoは不要)
  - updateBoard関数にlastMove?: Position引数を追加し、盤面更新と同時に棋譜記録を行う
  - lastMoveが指定された場合はpositionToNotationで変換しmoveHistoryに追加する
  - resetGame関数を拡張し、棋譜履歴も空配列にリセットする機能を追加する
  - 既存のゲーム状態管理との一貫性を保つ実装を行う
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5, 5.1, 5.2, 5.3, 5.4_

- [x] 3.1 useGameState棋譜管理機能の統合テスト作成
  - updateBoard実行時にlastMove指定→moveHistory追加→notationString更新の一連の流れを検証する
  - 複数手の連続追加が正しく記録されることを確認する(黒白黒の順序検証)
  - resetGame実行→moveHistory空配列、notationString空文字列を検証する
  - パス処理(lastMove未指定)で棋譜が記録されないことを確認する
  - AI着手もmoveHistoryに記録されることを確認する
  - _Requirements: 2.1, 2.2, 2.3, 2.4, 2.5, 5.1, 5.2, 5.3, 5.4_

- [x] 4. GameBoardコンポーネントへの棋譜表示UI追加
  - 画面下部(パスボタンの下)に棋譜表示領域を配置する
  - notationStringが空でない場合のみ表示する条件分岐を実装する
  - ゲーム進行中(playing状態)のみ表示する条件を追加する
  - Tailwind CSSで控えめなスタイル(text-sm, text-gray-600)を適用する
  - 横スクロール可能なスタイル(overflow-x: auto)を設定する
  - data-testid="move-history"属性を追加しテスト可能にする
  - _Requirements: 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7_

- [x] 4.1 GameBoardでの着手時updateBoard呼び出しの更新
  - handleCellClick関数内のupdateBoard呼び出しにlastMove引数(position)を追加する
  - AI着手useEffect内のupdateBoard呼び出しにlastMove引数(move)を追加する
  - パス処理のupdateBoard呼び出しはlastMove未指定のまま維持する
  - useGameStateから受け取ったnotationStringを表示領域に反映する
  - React State更新によるUI自動再レンダリングを活用する
  - 既存のゲームフローを変更せず最小限の統合を行う
  - _Requirements: 2.2, 2.3, 4.4, 4.5, 5.2_

- [x] 5. E2Eテストの実装(棋譜表示機能)
  - 画面下部に棋譜表示領域が存在することを確認するテストを作成する
  - 初期状態では表示領域が空または非表示であることを検証する
  - ユーザーが1手打った後に棋譜が更新されることを確認する
  - AIが1手打った後にも棋譜が更新されることを確認する
  - 3手進行後に"e6f6f5"のような期待される棋譜文字列が表示されることを検証する
  - 座標変換の正しさを検証する（row=列文字、col=行番号）
  - _Requirements: 4.1, 4.4, 4.7_

- [x] 5.1 長い棋譜の横スクロール動作E2Eテスト作成
  - 40手以上進行させた長い棋譜を生成するテストシナリオを作成する
  - 棋譜表示領域が横スクロール可能であることを確認する
  - 長い棋譜が表示領域を超えても正しく表示されることを検証する
  - モバイルデバイスでのスクロール動作も確認する
  - テキストが途切れず完全に表示されることを検証する
  - ゲーム終了時の早期リターンを適切にハンドリングする
  - _Requirements: 4.6_

- [x] 5.2 ゲームリセット時の棋譜クリアE2Eテスト作成
  - ゲームを数手進行させてから新しいゲームを開始するシナリオを作成する
  - リセット後に棋譜表示が空または非表示になることを確認する
  - リセット後の新しいゲームで棋譜が正しく記録されることを検証する
  - 複数回のリセットが正常に機能することを確認する
  - リセット後に着手を行い棋譜表示が復活することを検証する
  - _Requirements: 5.3_

- [x] 6. パフォーマンステストと統合検証
  - 60手(満局)の棋譜文字列生成が1ms未満で完了することを検証する
  - notationString計算がレンダリング毎に実行されるがパフォーマンス影響がないことを確認する
  - 1着手あたりのState更新回数が想定範囲内(1-2回)であることを検証する
  - 棋譜表示追加によるGameBoard再レンダリング時間増加が5ms以内に収まることを確認する
  - React Developer Toolsで不要な再レンダリングが発生していないことを検証する
  - _Requirements: 全要件のパフォーマンス保証_

- [x] 7. テストカバレッジ検証と最終統合確認
  - 棋譜機能全体のテストカバレッジが90%以上であることを確認する
  - 全ての要件がタスクと紐付けられていることを検証する
  - 既存のゲームロジックとの統合に問題がないことを確認する
  - TypeScript strict mode準拠とlint/format checkをパスすることを検証する
  - E2Eテスト(Desktop Chrome, Mobile Chrome, Mobile Safari)が全て成功することを確認する
  - _Requirements: 6.5, 全要件の完全実装確認_

---

## Requirements Coverage Matrix

| Requirement ID | Covered by Tasks |
| -------------- | ---------------- |
| 1.1            | 1, 1.1           |
| 1.2            | 1, 1.1           |
| 1.3            | 1, 1.1           |
| 1.4            | 1, 1.1           |
| 1.5            | 1, 1.1           |
| 1.6            | 1, 1.1           |
| 2.1            | 3, 3.1           |
| 2.2            | 3, 3.1, 4.1      |
| 2.3            | 3, 3.1, 4.1      |
| 2.4            | 3, 3.1           |
| 2.5            | 3, 3.1           |
| 3.1            | 2, 2.1           |
| 3.2            | 2, 2.1           |
| 3.3            | 2, 2.1           |
| 3.4            | 2, 2.1           |
| 3.5            | 2, 2.1           |
| 4.1            | 4, 5             |
| 4.2            | 4                |
| 4.3            | 4                |
| 4.4            | 4, 4.1, 5        |
| 4.5            | 4, 4.1           |
| 4.6            | 4, 5.1           |
| 4.7            | 4, 5             |
| 5.1            | 3                |
| 5.2            | 3, 4.1           |
| 5.3            | 3, 5.2           |
| 5.4            | 3                |
| 5.5            | 3.1              |
| 6.1            | 1                |
| 6.2            | 1                |
| 6.3            | 2, 2.1           |
| 6.4            | 1, 2, 2.1        |
| 6.5            | 1.1, 2.1, 7      |
| 6.6            | 1.1, 2.1         |

**全要件カバレッジ**: 全34項目の要件が上記タスクで完全にカバーされています。

---

## Design Decisions Reflected in Tasks

### Decision 4の反映: 統合タイミングと方法

- **Task 3**: `updateBoard`関数に`lastMove?: Position`引数を追加し、盤面更新と同時に棋譜記録を実装
- **Task 4.1**: GameBoard内の既存`updateBoard`呼び出しに`lastMove`引数を追加(ユーザー着手・AI着手)
- **Task 3.1**: パス処理で`lastMove`未指定の動作を検証

この設計により、棋譜記録の統合が一元化され、呼び出し漏れのリスクが排除されます。

### Decision 5の反映: エラー検出方針

- **Task 1**: `positionToNotation`内で座標範囲検証とフォールバック実装
- **Task 3.1**: 統合テストで着手数と棋譜数の整合性を検証(Requirement 5.5)
- 着手数と棋譜数の不一致検出はテストコードで対応(ランタイム検出は実装しない)
